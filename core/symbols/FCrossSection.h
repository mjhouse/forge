#ifndef __FCROSSSECTION_H__
#define __FCROSSSECTION_H__
      
#include <QtGui/QVector2D>
#include <QtWidgets/QWidget>

#include "FGeometry.h"
#include "FSymbol.h"

#define DEPTH_NORMAL QVector3D(0.0, 0.0, 1.0)
#define DEPTH_LENGTH 0.5

class FCrossSection : public FSymbol {

private:
	
	FGeometry* m_geometry;

	std::vector<QVector3D> m_vertices;	/*!< The vertices of the tesselated crosssection */

	std::vector<QVector3D> m_normals;	/*!< The calculated normals of the thickened crosssection */

	std::vector<uint> m_indices;		/*!< Indices generated by tesselation */

	void initialize(std::vector<QVector3D>& t_coordinates);

	/* Find triangles for the 2D surface */
	void tessellate();

protected:
	void propertyChanged(std::string t_name, FProperty t_property) {
		if (t_name == "length" && m_vertices.size() > 0)
			updateGeometry();
	}

public:
	FCrossSection();

	FCrossSection(FCrossSection* t_other);

	/* Set the reference points of the crosssection */
	void setGeometry(std::vector<QVector3D>& t_points);

	/* Convert the crosssection to 3D geometry */
	FGeometry* toGeometry();

	/* Update the associated geometry */
	void updateGeometry();
	
	/* Set the length of the extruded crosssection */
	void setLength(float t_length);

	/* Get the length of the extruded crosssection */
	float length();

	FSymbol* copy() {
		return new FCrossSection(this);
	}

};

#endif // __FCROSSSECTION_H__
