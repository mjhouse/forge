#ifndef __FSYMBOL_H__
#define __FSYMBOL_H__

#include "FGeometry.h"
#include "json.hpp"

#include <QVector3D>

#include <string>
#include <vector>
#include <variant>

using json      = nlohmann::json;
using FProperty = std::variant<int, float, std::string>;

#define _setter(T)													\
	void setProperty(std::string t_name, T t_value) {				\
		if (!hasProperty<T>(t_name,t_value)){						\
			m_properties[t_name] = t_value;							\
			propertyChanged(t_name,m_properties[t_name]);			\
		}															\
	}																\

#define _fragment_shader(n)											\
public:																\
	const char* fragmentShader() override {							\
		return n;													\
	}																\
private:															\

#define _vertex_shader(n)											\
public:																\
	const char* vertexShader() override {							\
		return n;													\
	}																\
private:															\

class FSymbol {
private:

	std::map<std::string, FProperty> m_properties;

protected:

	/* \brief Callback is triggered when the value of a property
	 *		  changes.
	 */
	virtual void propertyChanged(std::string t_name, FProperty t_property) = 0;

public:

	static const char* DEFAULT_VERT;

	static const char* DEFAULT_FRAG;

	FSymbol()
		: m_properties() {}

	FSymbol(FSymbol* t_other)
		: m_properties(t_other->m_properties) {}

	virtual ~FSymbol() {}

	/* \brief Create an FSymbol from a given type-string
	 */
	static FSymbol* from(std::string& t_type);

	/* \brief Create a copy of an FSymbol
	 */
	virtual FSymbol* copy() = 0;
	
	/* \brief Set the geometry of the symbol- these points
	 *		  are interpreted differently depending on the symbol.
	 */
	virtual void setGeometry(std::vector<QVector3D>& t_points) = 0;

	/* \brief Get a pointer to the FGeometry instance generated
	 *		  by the symbol.
	 */
	virtual FGeometry* toGeometry() = 0;

	/* \brief Update the FGeometry instance generated by
	 *		  this symbol.
	 */
	virtual void updateGeometry() = 0;

	/* \brief The fragment shader key
	 */
	virtual const char* fragmentShader() { return DEFAULT_FRAG; }

	/* \brief The vertex shader key
	 */
	virtual const char* vertexShader() { return DEFAULT_VERT; }

	_setter(int);
	_setter(float);
	_setter(std::string);

	void setProperty(std::string t_name, json::value_t t_type, json t_value);
	
	/* Check that property exists, has type T and value t_value */
	template <typename T>
	inline bool hasProperty(std::string t_name, T t_value) {
		return (hasProperty<T>(t_name) &&
			std::get<T>(m_properties[t_name]) == t_value);
	}

	/* Check that property exists, and has the given type */
	template <typename T>
	inline bool hasProperty(std::string t_name) {
		return (m_properties.count(t_name) != 0 &&
			std::holds_alternative<T>(m_properties[t_name]));
	}

	template <typename T>
	T property(std::string t_name) {
		return std::get<T>(m_properties[t_name]);
	}

};

#undef _setter
#endif